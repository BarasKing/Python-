## 组合数据类型

### 一、集合：
- 集合用{}表示，逗号间隔。具有无序性，内部元素不重复，因此内部元素不可变，可以是基本数据类型、元组、字符串，但不能是列表。
- 两个集合操作：& | - ^ >= <=
- 创建集合可以用{ }或者set{ }，但注意set{‘ahsbka’}实际上是把字符串类型转化为集合类型，因此形成的集合是由字符串的每一个字符充当一个元素的集合类型即{‘a’,’h’,’s’.’b’,’k’}，注意到虽然’a’在字符串中出现过两次，但是作为集合只能存在一个。
- 初始化创建空集合只能用set{ }，而不能直接用{ }，因为后者默认是生成字典dict
- 集合处理方法：<br>
1、增加元素：s.add(x)<br>
2、删除元素：s.discard(x)（若x不存在也不报错） s.remove(x)（若x不存在则报错） s.clear()（删除s里的所有元素）<br>
3、取出元素：s.pop()（随机返回s里的一个元素，并在s中删除它，若s为空则报错）<br>
4、返回副本：s.copy()  利用a=s.copy()可复制一个s到a，注意这时在内存中产生了两个一模一样的数据，而不是像a=s一样只是赋值了指针，内存中只有一份数据。<br>
5、返回s长度：len（s）<br>
6、判断元素是否在集合内：x in s<br>
7、将其他类型变量转化为集合类型：set(x)
- 集合应用：数据去重，如list ls=[‘p’,’p’,’y’,’y’,123] 想要得到去重后的list只需转化为一行代码就是ls=list(set(ls))，或者s=set(ls)然后，ls=list(s)

### 二、字典
- 字典是键值对的集合，是一种特殊的集合类型，键值对之间用冒号：表示，各键值对之间无序
- 创建字典可以用大括号{}或dict{}创建，注意集合只能用set{}的原因就是{}代表字典
- 字典可以用字典名[键名]来向字典变量中索引或增加元素，如d={'中国':'北京','美国':'华盛顿','法国':'巴黎'}，可以用t=d['中国']来得到键对应的值，即t='北京'，也可以用d['英国']='伦敦'来增加一对新的键值对元素。实际上键就是一种索引，其地位跟列表或者元组里的下标i一致
- 基本操作函数：<br>
1、元素长度：len(d)<br>
2、增加元素：d[k_new]=value_new（k_new必须是在原字典中未出现过的键）无法批量增加<br>
3、删除元素：del d[k]（k为键，删除字典中键k对应的键值对） d.clear()（删除所有键值对）<br>
4、判断元素是否在字典中：k in d（判断键k所代表的键值对是否在字典d中）<br>
5、取出元素：**d.get(k,default)** （若键k存在，则返回相应值，不存在则返回default值，get取出不会删除原有数据，这个函数很重要！！！） d.pop(k,<default>)（若键k存在，则取出相应值，不存在则返回default值，pop取出会删除原有数据） d.popitem()（随机从字典中取出一个键值对,元组形式）<br> 
for word in words: counts[word]=counts.get(word,0)+1 本循环的作用是遍历列表中的单词word，并将个数加到字典counts中，如果字典中一开始无此单词，则counts.get()返回0，该语句变为counts[word]=1,即在字典中新加入一组键值对，键为word，值为1<br>
- 键值对信息读取：<br>
1、返回字典d中所有的键信息：d.keys()<br>
\>>> d.keys()<br>
dict_keys(['中国', '美国', '法国'])<br> 
\>>> list(d.keys())<br>
['中国', '美国', '法国']<br>
2、返回字典d中所有的值信息：d.values()<br>
\>>> d.values()<br>
dict_values(['北京', '华盛顿', '巴黎'])<br>
\>>> list(d.values())<br>
['北京', '华盛顿', '巴黎']<br>
3、返回字典d中所有的键值对信息：d.items()<br>
\>>> d.items()<br>
dict_items([('中国', '北京'), ('美国', '华盛顿'), ('法国', '巴黎')])<br>
\>>> list(d.items())<br>
[('中国', '北京'), ('美国', '华盛顿'), ('法国', '巴黎')]<br>

### 三、序列：包括字符串、列表、元组
> 序列类型都是用s[]或s[][]来索引，值得一提的是对序列的统一操作都适用于这三种类型，比如:
- 统一操作符：x in s ; x not in s ; s+t ; s\*n / n\*s ; s[i] ; s[ i : j (:k)]注意在切片操作中，最后一个j位置的元素并没有被取到 <br>
你会发现除了字符串以外，对于列表和元组也可以使用+来连接，也可以用s*n的方式对其内容复制更新n倍<br>
而s[ : : -1]的操作相当于取全部的元素并倒序<br>
如序列s=[1 ,’w’, 2]，则s[ : : -1]=[ 2 , ‘w’ , 1]<br>
而对于字符串来说也可以用s[ : : -1]对其直接取反，如s=’abc’，s[ : : -1]=‘cba’<br>
对元组来说，create='cat','dog','tiger', create[ : : -1]='tiger','dog','cat'

- 统一操作函数：Len(s)可直接取其长度，min(s)取最小值,max(s)取最大值,但注意用max和min的时候其数据类型必须相同，否则会报错。s.count(x)用于统计x出现的总次数，s.index(x,i,j)用于取i到j范围内第一次出现x的下标

#### 字符串
- 字符替换：replace　s.replace(old, new[, count])用另一个字符串new替换指定子串old，并可以指定替换次数count，如s.replace('\n','')即把回车替换成空串
- 字符串转化为列表：split　s.split(',')通过指定的分隔符(默认为空格)将字符串拆分为一组子串并存放到列表中，如：s='a,b,c,d,e'  s.split(',')->['a','b','c','d','e']，经常使用**ls=s.split()** 将英文文本分词
- 列表转化为字符串：join　s='m'.join(ls)通过分隔符m将列表ls中的各个元素组合成一个字符串赋值给s，如：ls=['a','b','c']则没有分隔符为''.join(ls)='abc' 以逗号为分隔符为','.join(ls)='a,b,c' 
- 字符串大小写转化：lower、upper　s.lower()和s.upper()分别将字母字符转换为小写或大写
- 字符串出现次数统计：count　s.count(s1)返回子串s1在字符串s中出现次数

#### 元组
- 元组是一种序列类型，一旦被创建就不能被修改，并继承了序列的全部通用操作，但是如果元组里面有一个列表，列表内容是可变的，而元组存储的是列表的地址，因此元组实际上并没有被修改
- 创建元组可以用小括号()或者tuple()，元素间用逗号分隔，在使用元组时也可以不用小括号
- 由于固定不变的特性，元组一般用来函数多返回值，多变量同步赋值，循环遍历，如 def func(x): return x,x\**3; a,b='tiger','dog'; for x,y in ((1,0),(2,5),(3,8)) （类似于遍历某个点的坐标）

#### 列表
- 列表是一种序列类型，创建后可以被随意修改，值得注意的是，元组是一种特殊的列表，其区别仅在于元组最外围用圆括号()，且内部元素不能被修改；列表最外围用方括号[]，且内容可以被修改；两者都可以用for item in 元组名/列表名来遍历
- 创建列表可以用方括号[]或list()创建,元素间用逗号分隔，内部各元素类型可不同
- 赋值lt=ls仅仅是赋值指针而不是创建新的列表，如果用ls=[]就相当于创建了一个新的列表
- ls[i]=x可以替换列表单个元素，而ls[i:j(:k)]=lt则可以用列表lt来替换ls中的一段元素<br>
del ls[i]可以删除列表单个元素，而del ls[i:j(:k)]则可以删除ls中的一段元素，这是直接对列表本身操作<br>
ls+=lt可以把列表lt加到ls的后面，ls\*=n可以更新ls为元素重复n次的列表，这一部分内容与序列通用性质相符
- 基本操作函数:<br> 
1、列表长度：len(s)<br>
2、列表排序：sorted(ls)（对列表ls进行排序，sorted是python内置的排序函数，适用范围广）<br>
3、列表最大最小值：max(ls)和min(ls)<br>
4、增加元素：ls.append(x)（在列表最后增加一个元素x） ls.insert(i,x)（在ls的第i个位置增加元素x） ls+=lt（可以向ls同时加入多个元素）<br>
5、删除元素：ls.remove(x)（将列表中出现的第一个x删除） ls.clear()（删除ls中的所有元素） del ls[i]（删除列表单个元素，而del ls[i:j(:k)]则可以删除ls中的一段元素）<br>
6、取出元素：ls.pop(i)（把第i个位置的元素取出，并在列表中删除这个元素）<br>
7、列表取反：ls.reverse()   是将列表本身取反，而lt=ls[:,:,-1]仅仅是将ls取反的值给lt，ls本身没有变化<br>
8、修改元素：ls[i]=x可以替换列表单个元素，而ls[i:j(:k)]=lt则可以用列表lt来替换ls中的一段元素，可看做把原先的一段片段删除，再插入新的片段，这样就不会因为两个片段长度不一致而产生困扰<br>
- **排序及列表排序详解** 对Python内置函数sorted()和list（列表）中的成员函数list.sort()进行对比。在本质上，list的排序和py内置函数sorted的排序是差不多的，连参数都基本上是一样的。主要的区别在于，list.sort()是对已经存在的列表进行操作，会改变列表本身。而内置函数sorted返回的是一个新的list，而不会改变列表本身<br>
python内置函数sorted(iterable, key=None, reverse=False)：只要是可迭代对象数据（列表、元组、字典、字符串），都能够进行排序，生成一个排序后的**列表**，值得注意的是生成的排序结果必然是列表。如：元组：sorted((1,4,8,9,3,6))->[1, 3, 4, 6, 8, 9] 字符串：sorted('gafrtp')->['a', 'f', 'g', 'p', 'r', 't'] ,以上结果默认是从小到大输出，如果要从大到小输出的话，在参数列表中加一个reverse=True即可。<br>
二维及多维用法：利用参数key和lambda来定义排序的标准。这里，列表里面的每一个元素都为二维元组，key参数传入了一个lambda函数表达式，其x就代表列表里的每一个元素，然后分别利用索引返回元素内的第一个和第二个元素，这就代表了sorted()函数利用哪一个元素进行排列（如果是二维的话就是用那一列来进行排序）。而reverse参数就如同上面讲的一样，起到逆排的作用。默认情况下，reverse参数为False。<br>
\>>>ls=[('a', 1), ('b', 2), ('c', 6), ('d', 4), ('e', 3)]<br>

\>>>sorted(ls, key=lambda x:x[0])（按照第一列升序排序）<br>
[('a', 1), ('b', 2), ('c', 6), ('d', 4), ('e', 3)]<br>

\>>>sorted(ls, key=lambda x:x[0], reverse=True)（按照第一列降序排序）<br>
[('e', 3), ('d', 4), ('c', 6), ('b', 2), ('a', 1)]<br>

\>>>sorted(ls, key=lambda x:x[1])（按照第二列升序排序）<br>
[('a', 1), ('b', 2), ('e', 3), ('d', 4), ('c', 6)]<br>

\>>>sorted(ls, key=lambda x:x[1], reverse=True)（按照第二列降序排序）<br>
[('c', 6), ('d', 4), ('e', 3), ('b', 2), ('a', 1)]<br>

还有对一维列表来说，可以用类似sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5-x))<br>
将列表[1, 2, 3, 4, 5, 6, 7, 8, 9]按照元素与5距离从小到大进行排序，其结果是[5, 4, 6, 3, 7, 2, 8, 1, 9]。<br>

list自带的函数sort(key=None, reverse=False)，和sorted（排序不改变列表本身）相比，少了第一个参数,并且排序改变列表本身。<br>
\>>>ls=[('a', 1), ('b', 2), ('c', 6), ('d', 4), ('e', 3)]<br>

\>>>ls.sort(key=lambda x:x[0])<br>
\>>>ls（按照第一列升序排序）<br>
[('a', 1), ('b', 2), ('c', 6), ('d', 4), ('e', 3)]<br>

\>>>ls.sort(key=lambda x:x[0], reverse=True)<br>
\>>>ls（按照第一列降序排序）<br>
[('e', 3), ('d', 4), ('c', 6), ('b', 2), ('a', 1)]<br>

\>>>ls.sort(key=lambda x:x[1])<br>
\>>>ls（按照第二列升序排序）<br>
[('a', 1), ('b', 2), ('e', 3), ('d', 4), ('c', 6)]<br>

\>>>ls.sort(key=lambda x:x[1], reverse=True)<br>
\>>>ls（按照第二列降序排序）<br>
[('c', 6), ('d', 4), ('e', 3), ('b', 2), ('a', 1)]<br>

### jieba库
- **jieba.lcut(s)** （精确模式，返回一个列表类型的分词结果，最重要的函数，必须记住！！！）如：jieba.lcut('中国是一个伟大的国家')->['中国','是','一个','伟大','的','国家']
- jieba.lcut(s,cut_all=True)（全模式，返回一个列表类型的分词结果，存在冗余） 如：jieba.lcut('中国是一个伟大的国家'，cut_all=True)->['中国','国是','一个','伟大','的','国家']
- jieba.lcut_for_search(s)（搜索引擎模式，返回一个列表类型的分词结果，存在冗余，先按精确模式分词，再把稍长的词继续分词） 如：jieba.lcut_for_search('中华人民共和国是伟大的')->['中华', '华人', '人民', '共和', '共和国', '中华人民共和国', '是', '伟大', '的']
- jieba.add_word(w)（向分词词典增加新词w，可以先通过一遍分词，发现有分错的，如'习大大'分成了'习''大大'，则可以用jieba.add_word('习大大')这样词库里就多了习大大这个词语）
